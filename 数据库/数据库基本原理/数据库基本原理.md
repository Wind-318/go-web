## 概论
- ### 什么是数据库
数据库是数据管理的有效技术，是由一批数据构成的有序集合。
- ### 什么是SQL
SQL(Structured Query Language)：结构化查询语言，是一种特定的程序语言，用于管理和操作**关系型数据库**。
## SQL基本语法
- 增：
```sql
-- 创建一个teach数据库
CREATE DATABASE teach;
-- 使用teach数据库
USE teach;
--创建一个test表
CREATE TABLE test(
	-- ID作为主键，自动增长
    ID INT UNSIGNED PRIMARY KEY AUTO_INCREMENT ,
	-- varchar类型的name，长度最大为50
    NAME VARCHAR(50) NOT NULL
);
-- 插入一个路人甲和路人乙
INSERT INTO test VALUES(1, "路人甲");
INSERT INTO test VALUES(2, "路人乙");
```
表结构如下
| ID | NAME |
| :--: | :--: |
|  1  |  路人甲  |
|  2  |  龙套乙  |
- 删：
```sql
-- 删除路人乙
DELETE FROM test WHERE NAME = "路人乙";
-- 删除table表
DROP TABLE test;
```
- 改：
```sql
-- 将路人甲改名为龙套丙
UPDATE test SET NAME = "龙套丙" WHERE ID = 1;
-- 给表中添加一行年龄字段
ALTER TABLE test ADD COLUMN AGE INT UNSIGNED;
```
- 查：
```sql
-- distinct去重，相同名字只会出现一次，limit限制只返回100行
SELECT DISTINCT NAME FROM test LIMIT 100;
-- 查询表中所有信息，按ID降序排列
SELECT * FROM test ORDER BY ID DESC;
-- 查询表中所有信息，按ID升序排列
SELECT * FROM test ORDER BY ID ASC;
```
- 分组查询：
```sql
--按条件分成数组，并且统计每组数量，HAVING和WHERE相同，不过只能用于GROUP BY
-- HAVING是对分组后的数据筛选，同时可以使用函数，WHERE是对分组前筛选，不能用函数
SELECT count(条件) FROM 表名 GROUP BY 条件 HAVING 条件
```
- 内连接：
```sql
-- 建立省市表
CREATE TABLE `province` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `proNAME` varchar(30) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

-- 插入数据
insert into province(id,proNAME) values('1','安徽省');
insert into province(id,proNAME) values('2','江苏省');
insert into province(id,proNAME) values('3','浙江省');
```
表结构如下
| id | proNAME |
| :--: | :--: |
|  1  |  安徽省  |
|  2  |  江苏省  |
|  3  |  浙江省  |
```sql
-- 建立城市表
CREATE TABLE `city` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `NAME` varchar(30) NOT NULL,
  `fromid` int unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

-- 插入数据
insert into city(id,NAME,fromid) values('1','合肥市','1');
insert into city(id,NAME,fromid) values('2','马鞍山市','1');
insert into city(id,NAME,fromid) values('3','芜湖市','1');
insert into city(id,NAME,fromid) values('4','南京市','2');
insert into city(id,NAME,fromid) values('5','苏州市','2');
```
表结构如下
| id | NAME | fromid |
| :--: | :--: | :--: |
|  1  |  合肥市  |  1  |
|  2  |  马鞍山市  |  1  |
|  3  |  芜湖市  |  1  |
|  4  |  南京市  |  2  |
|  5  |  苏州市  |  2  |
```sql
-- 内连接查询
SELECT city.NAME, province.proNAME
FROM province
INNER JOIN city
ON city.fromid = province.id
```
表结构如下
| id | NAME | proNAME |
| :--: | :--: | :--: |
|  1  |  合肥市  |  安徽省  |
|  2  |  马鞍山市  |  安徽省  |
|  3  |  芜湖市  |  安徽省  |
|  4  |  南京市  |  江苏省  |
|  5  |  苏州市  |  江苏省  |
- 外连接：
```sql
-- 示例表同上，左连接查询语句如下
SELECT city.NAME, province.proNAME
FROM province
LEFT JOIN city
ON city.fromid = province.id
```
表结构如下
| id | NAME | proNAME |
| :--: | :--: | :--: |
|  1  |  合肥市  |  安徽省  |
|  2  |  马鞍山市  |  安徽省  |
|  3  |  芜湖市  |  安徽省  |
|  4  |  南京市  |  江苏省  |
|  5  |  苏州市  |  江苏省  |
|  6  |  NULL  |  浙江省  |

左连接以左表为准，匹配右边的表，没有匹配到的就显示NULL，右连接则相反，将LEFT JOIN变为RIGHT JOIN，以右表为准，全连接则显示所有数据，没有匹配的显示NULL。
- 联合查询：
```sql
-- 使用union关键字，将两个查询结果合在一起，默认去重，如果不去重要使用union all关键字
-- 全连接查询示例
SELECT city.NAME, province.proNAME
FROM province
LEFT JOIN city
ON city.fromid = province.id
UNION 
SELECT city.NAME, province.proNAME
FROM province
RIGHT JOIN city
ON city.fromid = province.id
```
## 事务和ACID
  - 事务是一组不可分割的操作的组合，这组操作要么全部成功，要么全部失败，作为一个最小单元存在。同时，事务还满足ACID特性。
  - ACID指的是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
    - 原子性：事务中的一组操作是不可分割的最小单位，就像原子一样，这组操作作为一个整体，要么全部成功，要么全部失败。
    - 一致性：事务完成前后的数据才可被外界访问，事务进行时的中间状态数据不能被访问。即数据只能从一个事务完成前正确的状态转移到另一个事务完成后正确的状态，而正在进行中的事务中的数据是非法的。
    - 隔离性：一个事务正在进行操作时对其它操作来说是不可见的。
    - 持久性：当事务完成时修改会永久保留，不会因断电等突发情况导致丢失更改。
  - Mysql采用自动提交模式，执行一个操作后会自动提交该事务。如果想显示开启事务需要使用begin开启事务，使用commit提交事务。
## 并发时的问题：
  - 脏读：当隔离性没有被满足时，一个操作读到另一个正在进行的事务中的数据，由于事务没有完成，所以读到了非法数据。这个数据就是脏数据。
  - 不可重复读：一个事务多次读取一个数据，同时还有其它操作正在对此数据进行操作，此时事务两次读取的数据不一样。
  - 幻读：一个事务正在读取一些数据，另一个操作对这部分数据进行增加和删除，导致事务读取到的数据不一样。与不可重复读的区别：幻读是数据数目不同，而不可重复读是数据内容不同。
  - 丢失修改：一个事务的操作被另一个事务覆盖，比如A事务更改了数据，B事务随后又更改了数据，覆盖了A事务的操作，或者B事务删除了这个数据，导致A事务的操作无效。
## 隔离级别
  - 未提交读：允许读取未提交数据。
  - 已提交读：只允许读取已经提交了的数据。可解决脏读问题。
  - 可重复读：只允许读取已经提交了的数据，而且在两次读取一个数据期间不允许其它事务更新该数据。可解决脏读和不可重复读问题。
  - 可串行化：事务只能串行执行，可解决脏读、不可重复读和幻读问题。