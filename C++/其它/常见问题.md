# 常见问题
- ### new 和 delete 与 malloc 和 free 区别
  - malloc 和 free 是库函数，需要头文件，new 和 delete 是关键字
  - new 申请后返回所需对象类型的指针，malloc 返回 void 类型的指针，需要强转
  - 用 new 会调用对象的构造函数，malloc 不会
- ### define 和 const 区别
  - define 在编译预处理阶段，const 在编译和运行阶段
  - define 不做类型检查，const 会检查
  - define 没有内存占用，const 有
- ### 内存管理
  - 内存分为堆区、栈区、全局/静态存储区和代码区
  - 栈区：由系统申请，由系统释放
  - 堆区：由用户申请，由用户释放
  - 全局区：存放全局变量/静态变量
  - 代码区：存放二进制代码
- ### volatile 关键字
  - 编译器不会对 volatile 关键字修饰的变量进行优化
- ### 四种强制类型转换
  - **static_cast**：可用于将派生类指针转为基类指针或在基本类型间转换
  - **const_cast**：用于强制去除**指向常数对象的指针**的常数特性，去除常量的对象必须是指针或引用
  - **reinterpret_cast**：将指针转换为整型或将整型转换为指针
  - **dynamic_cast**：其它三种是编译时完成，dynamic_cast 是运行时完成，在父子类指针间转换，父类中要有虚函数。
- ### 迭代器失效
  - 序列式容器通过 erase 返回下一个迭代器，关联式容器直接 ++，递增迭代器
- ### STL 组件
  - 容器、配接器、算法、仿函数、空间配置器、迭代器
  - 关系：容器通过空间配置器取得存储空间，算法通过迭代器存储容器内容，仿函数辅助算法实现策略变化，配接器修饰仿函数。
- ### 虚函数表
  - 在有虚函数的类的实例中，表被分配到实例内存中，虚函数表的指针存在于对象示例中最前面的位置。无函数覆盖时，子类虚函数表存放父类的函数，同时虚函数按声明顺序存放，且父类虚函数在子类前。有函数覆盖时，子类的函数会覆盖父类的函数存放在虚函数表中。多重继承时则通过多张虚函数表同上排列。
  - 虚析构函数：不加虚析构则只会释放父类的资源，而不会调用子类析构函数。
  - 为什么构造函数不能是虚函数：定义子类对象时，虚函数指针先指向父类虚函数表，父类构造完后子类虚函数表才指向自己的虚函数表，构造时先找虚函数指针，此时指针还未初始化。