# 常见问题
- ### new 和 delete 与 malloc 和 free 区别
  - malloc 和 free 是库函数，需要头文件，new 和 delete 是关键字
  - new 申请后返回所需对象类型的指针，malloc 返回 void 类型的指针，需要强转
  - 用 new 会调用对象的构造函数，malloc 不会
- ### 内存管理
  - 内存分为堆区、栈区、全局/静态存储区和代码区
  - 栈区：由系统申请，由系统释放
  - 堆区：由用户申请，由用户释放
  - 全局区：存放全局变量/静态变量
  - 代码区：存放二进制代码
- ### 四种强制类型转换
  - **static_cast**：可用于将派生类指针转为基类指针或在基本类型间转换
  - **const_cast**：用于强制去除**指向常数对象的指针**的常数特性，去除常量的对象必须是指针或引用
  - **reinterpret_cast**：将指针转换为整型或将整型转换为指针
  - **dynamic_cast**：其它三种是编译时完成，dynamic_cast 是运行时完成，在父子类指针间转换，父类中要有虚函数。
- ### 迭代器失效
  - 序列式容器通过 erase 返回下一个迭代器，关联式容器直接 ++，递增迭代器
- ### STL 组件
  - 容器、配接器、算法、仿函数、空间配置器、迭代器
  - 关系：容器通过空间配置器取得存储空间，算法通过迭代器存储容器内容，仿函数辅助算法实现策略变化，配接器修饰仿函数。
- ### 虚函数表
  - 虚函数表在编译期确定
  - 在有虚函数的类的实例中，表被分配到实例内存中，虚函数表的指针存在于对象示例中最前面的位置。无函数覆盖时，子类虚函数表存放父类的函数，同时虚函数按声明顺序存放，且父类虚函数在子类前。有函数覆盖时，子类的函数会覆盖父类的函数存放在虚函数表中。多重继承时则通过多张虚函数表同上排列。
  - 虚析构函数：不加虚析构则只会释放父类的资源，而不会调用子类析构函数。
  - 为什么构造函数不能是虚函数：定义子类对象时，虚函数指针先指向父类虚函数表，父类构造完后子类虚函数表才指向自己的虚函数表，构造时先找虚函数指针，此时指针还未初始化。
- ### inline 和 宏定义的区别
  - 宏只是在代码处不加验证的简单替换，内联函数是将代码嵌在调用处，减少函数跳转带来的消耗；
  - 内联函数在编译时展开，宏在预编译时展开；
  - 内联函数有类型检测、语法判断，宏没有；
  - 宏有歧义（需要用括号），内联函数没有。
- ### mutable
  - 被 mutable 修饰的变量，即使在 const 成员函数中也可以修改，处于 mutable 修饰的变量将永远处于可变状态。
- ### static
  - 静态成员被所有类的对象共享。
  - 静态成员函数只能访问静态数据成员，因为该函数没有 this 指针。
  - 静态全局变量在文件内可见，文件外不可见。
- ### 对象构造过程
  - 分配空间：全局对象、静态对象和栈区内的对象在编译时完成内存分配，堆上的对象在运行时动态分配。
  - 初始化：通过初始化列表完成
  - 赋值：执行构造函数
- ### const 与 define
  - define 在预编译时进行简单的替换，const 在编译器确定值
  - define 不检查类型，const 有类型
  - define 不分配内存，但会在内存中有多个拷贝，const 只有一份拷贝
- ### const 和 constexpr
  - 为了消除二义性，c++ 11 引入 constexpr 代表常量，原 const 代表只读含义。constexpr 在编译器可知。
- ### volatile
  - volatile 代表“易变的”，修饰的变量可以被未知因素修改，所以编译器对访问改变量的代码将不再进行优化。
- ### extern
  - 被 extern 修饰的变量或函数标识定义在别的文件中，提示编译器在别的文件中寻找定义。
  - extern C 指示编译器将这段代码按 C 的方式编译。
- explicit
  - 声明为 explicit 的构造函数不能发生隐式类型转换。
- ### 实现 sizeof
  ```C++
  // T 为类型
  size_t((T*)0 + 1)
  
  // T 为变量
  size_t((&T + 1) - (&T))
  ```
- ### 实现 strcpy
  ```C++
  char* strCpy(char* target, const char* src) {
    if (!target || !src) {
      return NULL;
    }

    char* temp = target;
    while (*src != '\0') {
      *temp++ = *src++;
    }
    *temp = '\0';

    return target;
  }
  ```
- ### 实现 memcpy
  ```C++
  void* Mem(void* des, void* src, size_t count) {
    if (!des || !src) {
      return NULL;
    }
    int* des1 = (int*)des, * src1 = (int*)src;

    int count1 = count / 4;
    int count2 = count % 4;

    while (count1--) {
      *des1++ = *src1++;
    }

    char* des2 = (char*)des1, * src2 = (char*)src1;

    while (count2--) {
      *des2++ = *src2++;
    }

    return des;
  }
  ```
- ### 堆和栈的区别
  - 栈由高地址位向低地址位生长，堆由低地址向高地址生长
  - 栈容量小，堆容量大。
  - 栈的空间由系统申请，由系统释放，堆的空间由用户自己管理
  - 栈申请速度快，堆慢
- ### 内存对齐作用
  - 提升 CPU 访问速度（CPU 一块一块地读取内存） 
  - 跨平台使用
- ### C++ 11 新特性
  - auto 类型推导
  - using 定义别名
  - lambda 表达式
  - 范围 for 循环
  - 智能指针
  - constexpr
  - 右值引用
  - 移动语义
  - nullptr 