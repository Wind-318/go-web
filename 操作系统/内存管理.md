## 物理内存
## 虚拟内存
## 分页
## 分段
## 页面置换算法
- ### 最优页面置换算法
  - 置换最长时间不会访问的页面。但算法无法实现，因为无法预测下一次访问的页面。
- ### 最近未使用
  - NRU（Not Recently Used）使用R与M位构造算法。发生缺页中断时，系统检查页面的R位和M位，把他们分为四类：
    - 第0类：没有被访问，没有被修改。
    - 第1类：没有被访问，已被修改。
    - 第2类：已被访问，没有被修改。
    - 第3类：已被访问，已被修改。
  - 算法随机从最小的非空类中挑出一个页面淘汰。
  - 算法隐含的意思为：淘汰一个没有被访问的已修改页面比淘汰一个经常访问的“干净”页面好。
- ### 先进先出
  - 系统维护一个在内存中的页面的链表，最新进入的页面放在表尾，最早进入的在表头，发生缺页中断时，淘汰表头的页面并把新加入的页面放到表尾。因为可能淘汰经常使用的页面，所以很少使用此算法。
- ### 第二次机会
  - 先进先出算法容易淘汰经常使用的页面，因此进行改进：检查最老页面的R位，如果R位是0，说明页面既老又没有被使用，直接置换；如果是1，则将R位变为0，放到链表尾端，同时修改时间，就像刚进入一样。![](第二次机会.jpg)
- ### 时钟页面置换
  - 第二次机会算法需要经常在表中移动页面，更好的办法是将所有页面保存在一个类似钟面的环形链表中，一个表针指向最老的页面。缺页中断时，首先检查表针指向页面，R位为0直接淘汰，R位为1则置0并把表针前移一个位置。![](时钟置换.jpg)
- ### 最近最少使用(LRU)
  - 发生缺页中断时，首先置换最长时间未使用的页面。
  - **实现：**[Leetcode.146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)
  - [C++实现](LRU.cpp)
- ### 最近最久未使用(LFU)
  - 首先置换最近使用频率最少的页面，如果使用频率相同，则置换最久未使用的页面。
  - **实现：**[Leetcode.460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)
  - [C++实现](LFU.cpp)