# 进程与线程
- ## 进程
  - 计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，一个进程就是一个正在执行程序的实例。**进程是资源分配的基本单位**。  进程拥有三种状态，分别是：
    - 运行态：该时刻进程实际占用CPU。
    - 就绪态：可运行，但因为其它进程正在允许而暂时停止。
    - 阻塞态：除非某种外部事件发生，否则进程不能运行。
- ## 孤儿进程与僵尸进程
  - 父进程结束后子进程仍在运行，子进程成为孤儿进程，子进程将被归属于 init 进程（进程 ID 为 1），因此不会产生危害。
- ## 线程
也被称为迷你进程，**是处理器调度和执行的基本单位**。一个进程可以有多个线程且至少有一个线程。一个进程中的线程共享进程的资源。
- ## 进程和线程的区别
  - #### 线程是调度和执行的基本单位，进程是资源分配的基本单位
  - #### 线程不拥有资源，但线程可以访问进程的资源
  - #### 每个进程拥有自己的资源，进程切换开销大，线程切换开销小。
  - #### 进程切换代价大，因为需要切换虚拟地址空间，线程共享空间，所以消耗小。
- ## 线程与进程的资源问题
  - #### 线程独有的资源有哪些？
    - 栈区：保存函数运行时的信息
    - 寄存器：用来保存一些局部变量和执行的指令
  - #### 线程间共享的数据有哪些？
    - 代码区
    - 堆区
    - 数据区
    - 栈区：如果一个线程得到另一个线程的栈指针，就能修改另一个线程的数据
- ## 进程间如何切换？
  - 中断 + 保存现场
- # 进程间通信
  - ## 临界区
    - 对临界资源进行访问的程序片段被称为临界区。
  - ## 同步、异步、互斥
    - 同步：进程因为相互制约，按顺序先后执行。   
    - 异步：进程不用等待其它进程的消息，只需要自己往后执行  
    - 互斥：多个进程同一时刻只有一个可以得到这个资源。
  - ## 互斥量
    - 互斥量是一个拥有两种状态的变量,分别为**加锁状态**和**解锁状态**，当加锁时，其它线程不能进入临界区，只有解锁时其它线程才能进入。
- # 进程通信方式
  - ## 信号量
    - 信号量使用一个整型变量来进行 down 和 up 操作，如果是 down 操作，则检查是否大于 0，如果大于就减一，然后继续；如果等于 0 就睡眠然后等待其值大于 0。如果是 up 操作就加一，让一个正在睡眠的进程完成 down 操作，这样就少了一个睡眠的进程。
    - [生产者——消费者问题（Producer-consumer problem）](https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98)  
  生产者不停生产物品，放入缓冲区，消费者不停从缓冲区中拿走物品消耗。当缓冲区满时生产者不会再放入物品，当缓冲区空时消费者也不会再拿走物品。
    - Go 语言实现：
      ```go
      package main

      import "fmt"

      func producer(ch chan<- int) {
        // 生产者一共生产 200 个物品
        for i := 0; i < 200; i++ {
          // 如果缓冲区满则阻塞
          ch <- i
        }
        // 关闭管道，通知消费者结束任务
        close(ch)
      }

      func consumer(ch <-chan int) {
        // 开始消费，如果缓冲区空则阻塞
        for i := range ch {
          fmt.Println(i)
        }
      }

      func main() {
        // 缓冲区为 100 容量
        ch := make(chan int, 100)
        // 生产者开始生产
        go producer(ch)
        // 消费者开始消费
        consumer(ch)
      }
      ```
  - ## 消息队列
    - 是保存消息的容器，满足先入先出原则，进程可以向消息队列中写入**消息**或者取出**消息**。并且消息队列只有在内核重启或者删除一个消息队列时才会被真正删除。
  - ## 无名管道
    - 只适用于父子进程之间通信且只能单向传输。
  - ## 有名管道
    - 有自己的名字和访问权限的限制，可以用于不相关进程间的通信，进程通过使用管道的名字获得管道。
  - ## 共享内存
    - 允许多个进程共享一片给定空间。
  - ## 信号
    - **信号用于通知一个进程已经发生**。
  - ## 套接字
    - 可以理解为不同主机间进程通信的端点的抽象，提供主机进程间交换数据的机制。
- ## 线程通信方式
  - 互斥量
  - 事件
  - 信号量
- ## 协程
  - 协程是轻量级的线程，是比线程更小的一种执行单位，某些语言在语言层面支持了协程，使得切换代价进一步降低。
  - 协程在用户态执行，切换代价小，同时无需加锁，所以效率高
# 调度
- ## 批处理系统
    - **先来先服务First-come First-served（FCFS）**：按照请求的顺序调度
    - **短作业优先Shortest job first（SJF）**：按估计运行时间最短的顺序调度
    - **最短剩余时间优先shortest remaining time next（SRTN）**：按剩余运行时间顺序调度
- ## 交互式系统
  - **轮转调度**：所有进程依次排队执行，每个进程执行一段时间后返回末尾继续排队等待执行。
  - **优先级调度**：按照给定进程的优先级决定谁先执行。
  - **多级队列**：设置多个队列，每个队列允许执行的时间不同，当一个进程在一个队列执行完后仍然没有完成，会转到其它队列继续排队。
# 经典IPC问题
- ## 哲学家进餐问题
  - 五个哲学家共用一张圆桌，每个哲学家有**干饭**和**思考**两种状态，每个哲学家左右各有**一只**筷子，所以每当一个哲学家拿起两边的筷子时，与他相邻的两个哲学家就会少一只筷子，无法继续干饭。
  - **以下为代码实现**：
    ```Go
    package main

    import (
      "fmt"
      "strconv"
      "sync"
      "time"
    )

    var wg sync.WaitGroup

    // 定义哲学家对象
    type philosopher struct {
      ID int
    }

    // 哲学家的吃饭行为
    func (p *philosopher) eating(mutex []sync.Mutex, i int) {
      // 哲学家左手边筷子加锁，如果还未解锁，会等待其它哲学家吃完解锁
      mutex[i%5].Lock()
      // 哲学家左手筷子延迟解锁
      defer mutex[i%5].Unlock()
      // 哲学家右手边筷子加锁，如果还未解锁，会等待其它哲学家吃完解锁
      mutex[(i+1)%5].Lock()
      // 哲学家右手边筷子延迟解锁
      defer mutex[(i+1)%5].Unlock()
      fmt.Println(strconv.Itoa(p.ID) + "正在干饭...")
      // 干饭中
      time.Sleep(time.Second)
      fmt.Println(strconv.Itoa(p.ID) + "干饭完毕")
    }

    func main() {
      // 5 个筷子对应 5 个互斥锁
      mutex := make([]sync.Mutex, 5)
      for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(i int) {
          // 创建哲学家对象
          pher := &philosopher{
            ID: i,
          }
          // 哲学家开始干饭
          pher.eating(mutex, i)
          wg.Done()
        }(i)
      }

      wg.Wait()
    }
    ```
- ## 读-写者问题
  - 允许多个线程读，但不允许多个线程同时读写或者多个线程同时写。
    ```Go
    // 声明一个读写锁
    rwMutex := &sync.RWMutex{}

    func RWmutexTest1(rwMutex *sync.RWMutex) {
      // 上读锁，可以有多个线程进入加多个锁
      rwMutex.RLock()
      // 解锁
      defer rwMutex.RUnlock()

      // work...
    }

    func RWmutexTest2(rwMutex *sync.RWMutex) {
      // 上写锁，只能由一个线程进入加锁，其它线程阻塞
      rwMutex.Lock()
      // 解锁
      defer rwMutex.Unlock()

      // work...
    }
    ```